---
description: Terraform coding standards and module best practices
globs:
  - "**/*.tf"
  - "**/*.tfvars"
alwaysApply: false
---

# Terraform Best Practices

## Module Focus and Structure

- **Single Purpose**: Design modules to serve a single, well-defined purpose (e.g., a VPC module, an S3 bucket module). This enhances reusability and reduces complexity.
- **Standard Directory Layout**: Follow a consistent structure:
  - `main.tf` for resources
  - `variables.tf` for inputs
  - `outputs.tf` for outputs
  - `versions.tf` for provider/Terraform versions
- **Documentation**: Include a comprehensive `README.md` explaining the module's purpose, usage, inputs, and outputs.

## Input Variables and Output Values

- **Clear Inputs**: Define clear input variables with descriptions, types, and default values where appropriate.
- **Expose Outputs**: Define explicit output values for any resource or data that might be needed by consuming configurations.
- **Variable Naming**: Name numeric variables with units (e.g., `ram_size_gb`, `disk_size_gb`).
- **Boolean Naming**: Give boolean variables positive names (e.g., `enable_external_access`).

## Code Style and Readability

- **Formatting**: Run `terraform fmt` for consistent formatting.
- **Validation**: Run `terraform validate` for early error detection.
- **Limit Complexity**: Keep expressions and logic within modules as simple as possible.
- **Use Built-in Functions**: Leverage Terraform's built-in functions to simplify code.
- **Avoid Custom Scripts**: Prioritize native Terraform features over custom shell scripts.

## Reusability and Versioning

- **Generic Design**: Aim for modules to be as generic and adaptable as possible.
- **Source Control**: Manage modules in source control to track versions and enable collaboration.
- **Module Registry**: Consider publishing reusable modules to a private or public module registry.

## State Management

- **Minimize Root Module Resources**: Avoid overly large root modules with too many resources in a single state file.
- **Protect Stateful Resources**: Use `lifecycle { prevent_destroy = true }` for critical resources.
- **One State Per Customer**: Use separate state backends per customer for isolation.
- **Use Workspaces**: Separate infrastructure components with workspaces.

## IAM Resource Management

- Prefer `google_*_iam_member` or `aws_iam_*` for additive bindings
- Use binding resources only when Terraform owns all members
- Avoid policy resources unless managing entire policy

## Operations

- Use `terraform plan -out=plan.tfplan` for safe applies
- Never store state locally for shared projects
- Use `moved` blocks for refactoring without recreation
